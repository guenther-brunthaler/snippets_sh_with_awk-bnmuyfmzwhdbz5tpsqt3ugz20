#! /bin/sh
set -e
test 'test $? = 0 || echo "$0 failed!" >& 2'
awk -f - -- "$@" << EOF && exit || false || exit
	function vinternal() {
		for (vmodulus= 1; vmodulus + 1 > vmodulus; ) {
			vmodulus+= vmodulus
		}
		vmodulus*= 0.5 # First bit is only implicit.
		vshiftin= vmodulus * 0.5 # The bit shifted in by vlsr().
	}

	function vinit(v, uint    , i) {
		if (!vmodulus) vinternal()
		for (i in v) delete v[i]
		v["n"]= 1
		v[0]= uint
	}

	function vdump(v    , i, n) {
		n= v["n"]
		for (i= 0; i < n; ++i) printf "[%u]= %.0f\n", i, v[i]
	}

	function vassign(dst, src    , i, ns, nd) {
		nd= dst["n"]; ns= src["n"]
		for (i= 0; i < ns; ++i) dst[i]= src[i]
		while (i < nd) delete dst[i++]
		dst["n"]= ns
	}

	function vadd(dst, add    , i, n, sum, carry) {
		if (add["n"] > (n= dst["n"])) dst["n"]= n= add["n"]
		for (carry= i= 0; i < n; ++i) {
			if ( \
				carry= (sum= dst[i] + add[i] + carry) \
					>= vmodulus \
			) { \
				sum-= vmodulus
			}
			dst[i]= sum
		}
		if (carry) {
			dst[n]= 1
			dst["n"]= n + 1
		}
	}

	function vnormalize(v    , n, i) {
		i= n= v["n"]
		while (i > 1 && v[i - 1] == 0) delete v[--i]
		if (i < n) v["n"]= i
	}

	function vmult(dst, mult    , add, m, i, j, n, b, b0) {
		vnormalize(dst); vnormalize(mult)
		# Ensure <m> becomes the shorter of <dst> and <mult>, and
		# <add> becomes the longer one.
		vinit(m); vinit(add)
		if ((n= mult["n"] - dst["n"]) == 0) {
			n= mult[mult["n"] - 1] - dst[dst["n"] - 1]
		}
		if (n <= 0) {
			vassign(m, mult); vassign(add, dst)
		} else {
			vassign(m, dst); vassign(add, mult)
		}
		n= m["n"]; vinit(dst, 0)
		# Use the schoolbook method because Karatsuba is only faster
		# for 320+ bit numbers, and we want to work with just 130 bit
		# numbers eventually.
		for (i= 0; i < n; ++i) {
			b= m[i]
			for (j= 1; j < vmodulus; j+= j) {
				b0= b * 0.5
				if ((b= int(b0)) != b0) {
					vadd(dst, add)
					if (!b && i + 1 == n) break
				}
				vadd(add, add)
			}
		}
	}

	# Returns the previous least significant bit that has been shifted out.
	function vlsr(dst    , carry, n, b) {
		vnormalize(dst)
		carry= 0
		for (n= dst["n"]; n--; ) {
			b= dst[n] * 0.5
			if (int(b) != b) {
				b= int(b) + carry
				carry= vshiftin
			} else {
				b+= carry
				carry= 0
			}
			dst[n]= b
		}
		vnormalize(dst)
		return !!carry
	}

	function vpow(dst, ex    , mult) {
		vnormalize(ex)
		if (ex["n"] == 1 && ex[0] == 0) {
			vinit(dst, 1) # dst^0 == 1.
			return
		}
		vinit(mult, 1)
		while (ex["n"] != 1 || ex[0] != 1) {
			if (vlsr(ex)) {
				# dst^(2*ex+1) == dst*(dst^(2*ex))
				vmult(mult, dst)
			}
			# dst^(2*ex) == (dst*dst)^ex
			vmult(dst, dst)
		}
		vmult(dst, mult)
	}

	# <dst> as well as <add> must be less than <mod>.
	function vmodsum(dst, add, mod    , i, n, sum, carry, borrow) {
		if (src["n"] > (n= mod["n"])) n= src["n"]
		if (n > dst["n"]) dst["n"]= n; else n= dst["n"]
		for (carry= borrow= i= 0; i < n; ++i) {
			if ( \
				carry= (sum= dst[i] + add[i] + carry) \
				>= vmodulus \
			) {
				sum-= vmodulus
			}
			dst[i]= sum
			borrow= (sum-= mod[i] - borrow) < 0;
		}
		if (!borrow) {
			for (borrow= i= 0; i < n; ++i) {
				if ( \
					borrow \
					= (sum= dst[i] - mod[i] - borrow) < 0 \
				) {
					sum+= vmodulus
				}
				dst[i]= sum
			}
		}
	}

	# <dst> as well as <mult> must be less than <mod>.
	function vmodmult(dst, mult, mod    , add, m, i, j, n, b, b0) {
		vnormalize(dst); vnormalize(mult)
		# Ensure <m> becomes the shorter of <dst> and <mult>, and
		# <add> becomes the longer one.
		vinit(m); vinit(add)
		if ((n= mult["n"] - dst["n"]) == 0) {
			n= mult[mult["n"] - 1] - dst[dst["n"] - 1]
		}
		if (n <= 0) {
			vassign(m, mult); vassign(add, dst)
		} else {
			vassign(m, dst); vassign(add, mult)
		}
		n= m["n"]; vinit(dst, 0)
		# Use the schoolbook method because Karatsuba is only faster
		# for 320+ bit numbers, and we want to work with just 130 bit
		# numbers eventually.
		for (i= 0; i < n; ++i) {
			b= m[i]
			for (j= 1; j < vmodulus; j+= j) {
				b0= b * 0.5
				if ((b= int(b0)) != b0) {
					vmodsum(dst, add, mod)
					if (!b && i + 1 == n) break
				}
				vmodsum(add, add, mod)
			}
		}
	}

	# <dst> must be less than <mod>.
	function vmodexp(dst, ex, mod    , mult) {
		vnormalize(ex)
		if (ex["n"] == 1 && ex[0] == 0) {
			vinit(dst, 1) # dst^0 == 1.
			return
		}
		vinit(mult, 1)
		# Reduce exponent until dst^1 == dst.
		while (ex["n"] != 1 || ex[0] != 1) {
			#print "dst= " v2str(dst) ", ex= " v2str(ex)
			if (vlsr(ex)) {
				# dst^(2*ex+1) == dst*(dst^(2*ex))
				vmodmult(mult, dst, mod)
			#	print "update mult factor= " v2str(mult)
			}
			# dst^(2*ex) == (dst*dst)^ex
			vmodmult(dst, dst, mod)
			#print "only squared: dst= " v2str(dst) ", new ex= " v2str(ex)
		}
		vmodmult(dst, mult, mod)
	}

	function v2str(v    , vn, i, j, k, n, o, b, carry, sum) {
		vnormalize(v); vn= v["n"]
		n= 0; o[n++]= 0
		for (i= vn; i--; ) {
			b= v[i]
			for (j= vmodulus; (j*= 0.5) >= 1; ) {
				if (carry= b >= j) b-= j
				for (k= 0; k < n; ++k) {
					sum= o[k]
					if (carry= (sum+= sum + carry) >= 10) {
						sum-= 10
					}
					o[k]= sum
				}
				if (carry) o[n++]= 1
			}
		}
		sum= ""
		for (k= n; k--; ) sum= sum o[k]
		return sum
	}

	function vstr2v(dst, str    , i, sl, c, a) {
		sl= length(str)
		vinit(dst, 0)
		for (i= 1; i <= sl; ++i) {
			if ((c= substr(str, i, 1)) < "0" || c > "9") {
				die("Invalid digit '" c "' in '" str "'!")
			}
			vassign(a, dst); vadd(a, a); vadd(a, a)
			vadd(dst, a); vadd(dst, dst)
			vinit(a, c + 0)
			vadd(dst, a)
		}
	}

	function die(msg) {
		print msg > "/dev/stderr"
		exit 1
	}

	BEGIN {
		if (ARGC < 4) {
			die("Arguments: <base> <exponent> <modulus>!")
		}
		vstr2v(x, ARGV[1])
		vstr2v(n, ARGV[2])
		vstr2v(mod, ARGV[3])
		vmodexp(x, n, mod)
		print v2str(x)
	}
EOF
